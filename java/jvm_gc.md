
## 垃圾回收器

### 垃圾回收算法及各种垃圾回收器

之前的笔记：[JVM内存管理](https://github.com/rainsbaby/notebook/blob/master/java/jvm_memory_manage.md)


## G1

### 问题

- G1有哪些特点？
- RSet、Card table是什么？
- SATB算法在什么阶段起作用？什么是三色标记法？
- 什么时候触发Young GC、MixedGC？
- 有哪些重要的参数？
- CMS 和 G1 有什么异同？

### G1的特点

- 基于Region的内存布局。G1将Java堆划分为多个大小相等的独立区域（Region），每个Region都可以根据需要，扮演新生代的Eden、Survivor空间或老年代空间。Region中还有个Humongous区域，专门用来存储大对象，是特殊的老年代Region。
- 面向局部收集。Region是单次回收的最小单元，每次收集到的内存空间是Region大小的整数倍。
- 建立了停顿预测模型（Pause Prediction Model）。G1跟踪各个Region里面垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定的允许停顿时间（-XX:MaxGCPauseMillis），优先处理回收价值收益最大的那些Region。

### Remembered Set

RSet的目的：为了解决对象跨代引用所带来的问题，在新生代中建立了名为RSet的数据结构，用于避免把整个老年代加进GC Roots扫描范围。

RSet有多种实现方式可以选择，可以使用不同的记录粒度：

- 字长靖度：每个记录精确到一个机器字长（如32位/64位）。
- 对象精度：每个记录精确到一个对象，该对象里有字段含有跨代指针。
- 卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针。

**Card Table**即为卡精度的RSet实现方式，这是目前最常用的RSet实现方式。一个卡页（一块内存区域，Hotspot中位512字节）中，只要有一个对象的字段存在跨代指针，就将对应卡表的数组元素的值标识为1.

### 三色标记法和SATB算法

当前主流编程语言的垃圾收集器基本都是依靠可达性分析算法来判定对象是否存活，这就需要从GC Roots开始对所有对象进行标记。GC Roots的枚举需要Stop the world，而从GC Roots向下遍历对象图耗时较长，一般需要并发标记。

CMS和G1在**并发标记**时使用的是同一个算法：三色标记法，使用白灰黑三种颜色标记对象。白色是未标记；灰色自身被标记，引用的对象未标记；黑色自身与引用对象都已标记。

GC 开始前所有对象都是白色，GC 一开始所有根能够直达的对象被压到栈中，待搜索，此时颜色是灰色。然后灰色对象依次从栈中取出搜索子对象，子对象也会被涂为灰色，入栈。当其所有的子对象都涂为灰色之后该对象被涂为黑色。当 GC 结束之后灰色对象将全部没了，剩下黑色的为存活对象，白色的为垃圾。

#### 对象消失

在可达性分析的扫描过程中，如果只有垃圾回收线程在工作，那肯定不会有任何问题。但是垃圾回收器和用户线程同时运行呢？

垃圾回收器在对象图上面标记颜色，而同时用户线程在修改引用关系，引用关系修改了，那么对象图就变化了，这样就有可能出现两种后果：

    一种是把原本消亡的对象错误的标记为存活，这不是好事，但是其实是可以容忍的，只不过产生了一点逃过本次回收的浮动垃圾而已，下次清理就可以。
    一种是把原本存活的对象错误的标记为已消亡，这就是非常严重的后果了，一个程序还需要使用的对象被回收了，那程序肯定会因此发生错误。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/jvm/jvm_gc_tri_color_marking.png)

扫描完成后，原本还在被对象A引用的对象C，由于是白色对象，所以根据三色标记原则，对象C会被当成垃圾回收。

当且仅当以下两个条件同时满足时，会产生"对象消失"的问题，原来应该是黑色的对象被误标为了白色：

    条件一：赋值器插入了一条或者多条从黑色对象到白色对象的新引用。
    条件二：赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。

**怎么解决"对象消失"问题呢？**

由于两个条件之间是当且仅当的关系。所以，我们要解决并发标记时对象消失的问题，只需要破坏两个条件中的任意一个就行。

于是产生了两种解决方案：

    增量更新（Incremental Update）
    原始快照（Snapshot At The Beginning，SATB）。

在HotSpot虚拟机中，CMS是基于增量更新来做并发标记的，G1则采用的是原始快照的方式，使用write barrier去记住B.c = null的操作

**增量更新**：要破坏的是第一个条件（赋值器插入了一条或者多条从黑色对象到白色对象的新引用），当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。

可以简化的理解为：黑色对象一旦插入了指向白色对象的引用之后，它就变回了灰色对象。

**原始快照**：要破坏的是第二个条件（赋值器删除了全部从灰色对象到该白色对象的直接或间接引用），当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一次。

可以简化理解为：无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照开进行搜索。

### 什么时候触发Young GC、MixedGC？

G1中YoungGC并不是现有的Eden区放满了就会马上触发，G1会计算下现在Eden区回收大概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时间接近参数 -XX:MaxGCPauseMills 设定的值，那么就会触发Young GC 。

当应用运行开始时，堆内存可用空间还比较大，只会在年轻代满时，触发年轻代收集；随着老年代内存增长，当到达IHOP阈值-XX:InitiatingHeapOccupancyPercent(老年代占整堆比，默认45%)时，G1开始着手准备收集老年代空间。首先经历并发标记周期，识别出高收益的老年代分区，前文已述。但随后G1并不会马上开始一次混合收集，而是让应用线程先运行一段时间，等待触发一次年轻代收集。在这次STW中，G1将保准整理混合收集周期。接着再次让应用线程运行，当接下来的几次年轻代收集时，将会有老年代分区加入到CSet中，即触发混合收集，这些连续多次的混合收集称为混合收集周期(Mixed Collection Cycle)。 

### Collection Set (CSet)




### 有哪些重要的参数？

‐XX:+UseG1GC -> 开启G1收集器

‐XX:G1HeapRegionSize -> 指定分区大小(1MB~32MB，且必须是2的幂)，默认将整堆划分为2048个分区。

**‐XX:MaxGCPauseMillis** -> 目标暂停时间(默认200ms)。是一个软性目标，G1会尽量达成，如果达不成，会逐渐做自我调整。

‐XX:G1NewSizePercent -> 新生代内存初始空间(默认整堆5%)。G1会根据实际的GC情况(主要是暂停时间)来动态的调整新生代的大小，主要是Eden Region的个数。

‐XX:G1MaxNewSizePercent -> 新生代内存最大空间。

‐XX:TargetSurvivorRatio -> Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代

**‐XX:InitiatingHeapOccupancyPercent** -> 老年代占用空间达到整堆内存阈值(默认45%)，则执行 新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近 1000个region都是老年代的region，则可能就要触发MixedGC了

‐XX:G1HeapWastePercent -> 默认5%， gc过程中空出来的region是否充足阈值，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的 Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着 本次混合回收就结束了。

‐XX:G1MixedGCLiveThresholdPercent -> 默认85%，region中的存活对象低于这个值时才会回收该region，如果超过这个值，存活对象过多，回收的的意义不大。

‐XX:G1MixedGCCountTarget -> 在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至于单次停顿时间过长。


### 建议

1. 年轻代大小：如果配置了-XX:+UseG1GC，那么尽量避免配置-Xmn（或 -XX:NewRatio 等其他相关选项显式设置年轻代大小）。如果设置该参数，G1将不能在需要的时候调整年轻代的大小，也不能根据设置的暂停时间调整收集策略。换句话说，如果配置了-Xmn，也就关闭了参数-XX:MaxGCPauseMillis=200设定的停顿目标，具体YGC的停顿时间，那就完全由-Xmn直接决定了。

2. 停顿时间：不要使用平均响应时间作为设置参数-XX:MaxGCPauseMillis=200的衡量标准，而应该根据90%（或者更高比例）响应时间来设置这个参数。需要强调的是，这个参数设定的只是一个目标，而不是一定达到的保证。不建议将这个参数设置的过低，例如100ms以内，除非针对你的应用，有充分的压测数据佐证你的设置。

3. **CMS or G1**，什么时候选择CMS，什么时候选择G1？CMS在较小的堆、合适的workload的条件下暂停时间可以很轻松的短于G1。以JDK8高版本为例（JDK7到JDK8，G1的实现经过了很多的优化），大概在6GB～8GB也可以跟CMS有一比。总之，G1更适合大堆，比如20G，30G，50G，不要犹豫选择G1吧。而对于4G，8G这种中小堆，如果谨慎的话，建议压测后再决定。否则CMS也是一个保守的选择。


### 参考资料

《深入理解Java虚拟机》第三版

[Getting Started with the G1 Garbage Collector](https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/G1GettingStarted/index.html)
[HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/en/java/javase/13/gctuning/garbage-first-garbage-collector.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573)

[Java Platform, Standard Edition HotSpot Virtual Machine Garbage Collection Tuning Guide](https://docs.oracle.com/javase/9/gctuning/toc.htm)

## ZGC

ZGC是为了解决G1的不足。G1有哪些不足？G1的目标是在可控的停顿时间内完成垃圾回收，所以进行了分区设计，在回收时采用部分内存回收（在YGC时会回收所有新生代分区，在混合回收时会回收所有的新生代分区和部分老生代分区），支持的内存也可以达到几十个GB或者上百个GB。为了进行部分回收，G1实现了RSet管理对象的引用关系。基于G1设计上的特点，导致存在以下问题：

- 停顿时间过长，通常G1的停顿时间要达到几十到几百毫秒；这个数字其实已经非常小了，但是我们知道垃圾回收发生导致应用程序在这几十或者几百毫秒中不能提供服务，在某些场景中，特别是对用户体验有较高要求的情况下不能满足实际需求。
- 内存利用率不高，通常引用关系的处理需要额外消耗内存，一般占整个内存的1%～20%左右。
- 支持的内存空间有限，不适用于超大内存的系统，特别是在内存容量高于100GB的系统中，会因内存过大而导致停顿时间增长。

ZGC作为新一代的垃圾回收器，在设计之初就定义了三大**目标**：支持TB级内存，停顿时间控制在10ms之内，对程序吞吐量影响小于15%。

G1中的停顿时间主要来自垃圾回收（YGC和混合回收）阶段中的复制算法，在复制算法中，需要把对象转移到新的空间中，并且更新其他对象到这个对象的引用。实际中对象的转移涉及内存的分配和对象成员变量的复制，而对象成员变量的复制是非常耗时的。在G1中对象的转移都是在STW中并行执行的，而ZGC就是把对象的转移也**并发执行**，从而满足停顿时间在10ms以下。

## Shenandoah

Shenandoah 和 G1 有相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路都高度一致，甚至直接共享一部分代码。不同的是，虽然 Shenandoah 也是基于 Region 的堆内存布局，回收策略也和 G1 一致，但在管理堆内存方面，它与 G1 至少有三个明显的不同：

    支持并发的整理算法，G1 的回收阶段可以多线程并行，但不能与用户线程并发。
    Shenandoah 默认不使用分代收集。
    Shenandoah 摒弃了在 G1 中需耗费大量资源去维护的记忆集，改用连接矩阵的全局数据结构来记录跨 Region 的引用关系。


Shenandoah 用于支持并发整理的核心是—— 转发指针（**Brooks Pointer**）。此前，要做类似的并发操作，通常要在被移动对象原有的内存上设置保护指针，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，进入预设好的异常处理器，再由其中的代码逻辑把访问转发到复制后的新对象。这种方式虽然能实现对象移动和用户线程并发，但如果没有操作系统层面的直接支持，将导致用户态频繁切换到核心态，代价巨大

转发指针是在原有对象布局结构的最前面统一增加一个新的引用字段，在正常情况下，该引用指向对象自己。当对象拥有一份新的副本时，只需修改一处指针的值，即旧对象上转发指针的引用位置，使其指向新对象，便可将所有对该对象的访问转发到新的副本上。这样只要旧对象的内存仍然存在，虚拟机内存中所有通过旧地址访问的代码仍可继续使用，都会被转发到新对象继续工作

## G1、ZGC、Shenandoah比较

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/jvm/jvm_gc_g1_zgc_shenandoah.png)

Shenandoah GC 与 ZGC 同为新一代的低延迟收集器, 分别由RedHat和Oracle开发, 目前还在实验阶段, 尚未使用于生产环境。

Shenandoah和ZGC在垃圾回收时非常类似，都实现了并发标记、并发转移和并发重定位。但Shenandoah的算法实现思路和ZGC不同，它更加类似于G1，把G1中的并行转移变成了并发转移。

并发，指垃圾回收线程与应用线程池同时运行，而不是STW。并行，指多个垃圾回收线程同时执行。

ZGC并发的基础是**地址多视图映射**。Shenandoah并发的基础是在对象头增加了一个额外的数据，称为**Brook pointer**，在实现读写屏障时通过Brook pointer访问对象。




