Redis (Remote Dictionary Server) 通常被称为数据结构服务器，因为值 (value) 可以是字符串 (String) , 哈希 (Map) , 列表 (list) , 集合 (Sets) 或有序集合 (Sorted Sets) 等类型。

Redis 比其他 key-value 缓存产品有以下三个特点：

    Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载到内存使用。
    Redis 不仅支持简单的 key-value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。
    Redis 支持主从复制，即 master-slave 模式的数据备份。

  
<br/>

## 简单动态字符串SDS

Simple Dynamic String 结构：

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_simple_dynamic_string.png)	

<br/>

## 字典

### 哈希算法

当要将一个新的键值对添加到字典里面时，程序需要先根据键值对的键计算出哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面。

当字典被用作数据库的底层实现，或者哈希键的底层实现时，Redis使用MurmurHash2算法来计算键的哈希值。

### 解决键冲突

当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）。

Redis的哈希表使用链地址法（separate chaining）来解决键冲突。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_hash_collision.png)

### rehash

随着操作的不断执行，哈希表保存的键值对会逐渐地增多或者减少，为了让哈希表的负载因子（loadfactor）维持在一个合理的范围之内，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行相应的扩展或者收缩。

扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：

- 为字典的ht[1]哈希表分配空间
- 将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。
- 当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。

### 渐进式rehash

扩展或收缩哈希表需要将ht[0]里面的所有键值对rehash到ht[1]里面，但是，这个rehash动作并不是一次性、集中式地完成的，而是分多次、渐进式地完成的。

哈希表渐进式rehash的详细步骤：

- 为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。
- 在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。
- 在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。
- 随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。

因为在进行渐进式rehash的过程中，字典会同时使用ht[0]和ht[1]两个哈希表，所以在渐进式rehash进行期间，字典的删除（delete）、查找（find）、更新（update）等操作会在两个哈希表上进行。

在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。


<br/>

## 跳跃表

跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。

在大部分情况下，跳跃表的效率可以和平衡树相媲美，并且因为跳跃表的实现比平衡树要来得更为简单，所以有不少程序都使用跳跃表来代替平衡树。

Redis在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构。


<br/>

## 整数集合

整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。

contents数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项（item），各个项在数组中按值的大小从小到大有序地排列，并且数组中不包含任何重复项。

### 升级

每当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级（upgrade），然后才能将新元素添加到整数集合里面。

升级整数集合并添加新元素共分为三步：

- 根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间。
- 将底层数组现有的所有元素都转换成与新元素相同的类型，并将类型转换后的元素放置到正确的位上，而且在放置元素的过程中，需要继续维持底层数组的有序性质不变。
- 将新元素添加到底层数组里面。

升级操作为整数集合带来了操作上的灵活性，并且尽可能地节约了内存。

整数集合只支持升级操作，不支持降级操作。


<br/>

## 压缩列表

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做列表键的底层实现。

另外，当一个哈希键只包含少量键值对，比且每个键值对的键和值要么就是小整数值，要么就是长度比较短的字符串，那么Redis就会使用压缩列表来做哈希键的底层实现。


<br/>

## 对象

Redis的主要数据结构包括SDS、双端链表、字典、压缩列表、整数集合等，Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个**对象系统**，这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。

通过这五种不同类型的对象，Redis可以在执行命令之前，根据对象的类型来判断一个对象是否可以执行给定的命令。使用对象的另一个好处是，我们可以针对不同的使用场景，为对象设置多种不同的数据结构实现，从而优化对象在不同场景下的使用效率。

> REDIS对象类型：
> REDIS_STRING: 字符串对象 
> REDIS_LIST: 列表对象
> REDIS_HASH: 哈希对象
> REDIS_SET: 集合对象
> REDIS_ZSET: 有序集合对象


### 对象的类型与编码

对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。

encoding属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。

Redis共有字符串、列表、哈希、集合、有序集合五种类型的对象，每种类型的对象至少都有两种或以上的编码方式，不同的编码可以在不同的使用场景上优化对象的使用效率。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_object_encoding.png)


### 内存回收

因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个**引用计数（reference counting）技术实现的内存回收机制**，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

除了用于实现引用计数内存回收机制之外，对象的引用计数属性还带有**对象共享**的作用。

目前，Redis会在初始化服务器时，创建一万个字符串对象，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

> 为什么redis不共享包含字符串的对象？
> 
> 当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象。
> 而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗的CPU时间也会越多。
> 
> 因此，尽管共享更复杂的对象可以节约更多的内存，但受到CPU时间的限制，Redis只对包含整数值的字符串对象进行共享。

### 对象的空转时长

除了type、encoding、ptr和refcount四个属性之外，redisObject结构包含的最后一个属性为lru属性，该属性记录了对象最后一次被命令程序访问的时间。

lru属性可用于计算对象的空转市场。如果服务器打开了maxmemory选项，并且服务器用于回收内存的算法为volatile-lru或者allkeys-lru，那么当服务器占用的内存数超过了maxmemory选项所设置的上限值时，空转时长较高的那部分键会优先被服务器释放，从而回收内存。

<br/>

## Redis Stream

Redis Stream 是 Redis 5.0 版本新增加的数据结构。

Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 Redis 发布订阅 (pub/sub) 来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。

而 Redis Stream 提供了**消息的持久化和主备复制功能**，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。


<br/>

## Redis 发布订阅

Redis 发布/订阅是一种消息传播模式，其中发送者发送消息，而接收者（订阅者）接收消息。传递消息的通道称为channel。

在Redis中，客户端可以订阅任意数量的频道。


<br/>

## Redis 事务

事务是指一个完整的动作，要么全部执行，要么什么也没有做。

Redis 事务**不是严格意义上的事务**，只是用于帮助用户在一个步骤中执行多个命令。单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。

Redis 事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。


<br/>

## 数据库

Redis服务器默认会创建16个数据库。

每个Redis客户端都有自己的目标数据库，每当客户端执行数据库写命令或者数据库读命令的时候，目标数据库就会成为这些命令的操作对象。

默认情况下，Redis客户端的目标数据库为0号数据库，但客户端可以通过执行SELECT命令来切换目标数据库。

数据库主要由**dict和expires两个字典**构成，其中dict字典负责保存键值对，而expires字典则负责保存键的过期时间。

### 键空间

redisDb结构的dict字典保存了数据库中的所有键值对，我们将这个字典称为键空间（key space）。

键空间和用户所见的数据库是直接对应的：

- 键空间的键也就是数据库的键，每个键都是一个字符串对象。
- 键空间的值也就是数据库的值，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。

### 设置键的生存时间或过期时间

通过EXPIRE命令或者PEXPIRE命令，客户端可以以秒或者毫秒精度为数据库中的某个键设置生存时间（Time To Live，TTL），在经过指定的秒数或者毫秒数之后，服务器就会自动删除生存时间为0的键。

数据库键的过期时间保存在过期字典中。

expires字典的键指向数据库中的某个键，而值则记录了数据库键的过期时间，过期时间是一个以毫秒为单位的UNIX时间戳。

带有过期字典的数据库：
![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_db_dict_withexpire.png)

过期键删除，三种不同的删除策略：

- 定时删除：在设置键的过期时间的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。
- 惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。
- 定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面的过期键。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。

Redis服务器实际使用的是**惰性删除和定期删除两种策略**：通过配合使用这两种删除策略，服务器可以很好地在合理使用CPU时间和避免浪费内存空间之间取得平衡。


### AOF、RDB和复制功能对过期键的处理

#### Redis持久化机制：AOF和RDB
Redis作为一个内存数据库，数据是以内存为载体存储的，那么一旦Redis服务器进程退出，服务器中的数据也会消失。为了解决这个问题，Redis提供了持久化机制，也就是把内存中的数据保存到磁盘当中，避免数据意外丢失。

Redis提供了两种持久化方案：RDB持久化和AOF持久化。

- RDB持久化是通过**快照**的方式，即在指定的时间间隔内将内存中的数据集快照写入磁盘。在创建快照之后，用户可以备份该快照，可以将快照复制到其他服务器以创建相同数据的服务器副本，或者在重启服务器后恢复数据。RDB是Redis默认的持久化方式。
- AOF（Append Only File）持久化功能，是将 redis 执行过的所有写指令记录下来，在下次 redis 重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了。

#### RDB对过期键的处理
创建一个新的RDB文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的RDB文件中。

服务器对RDB文件进行载入时：

- 如果服务器以主服务器模式运行，那么在载入RDB文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入RDB文件的主服务器不会造成影响。
- 如果服务器以从服务器模式运行，那么在载入RDB文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器在进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期键对载入RDB文件的从服务器也不会造成影响。

#### AOF对过期键的处理
当过期键被惰性删除或者定期删除之后，程序会向AOF文件追加（append）一条DEL命令，来显式地记录该键已被删除。

和生成RDB文件时类似，在执行AOF重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的AOF文件中。

#### 复制

当服务器运行在复制模式下时，从服务器的过期键删除动作由主服务器控制。

- 主服务器在删除一个过期键之后，会显式地向所有从服务器发送一个DEL命令，告知从服务器删除这个过期键。
- 从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键。（可能导致返回已过期的数据）
- 从服务器只有在接到主服务器发来的DEL命令之后，才会删除过期键。


### 数据库通知

客户端通过订阅给定的频道或者模式，来获知数据库中键的变化，以及数据库中命令的执行情况。


<br/>

## RDB持久化

因为Redis是内存数据库，它将自己的数据库状态储存在内存里面，所以如果不想办法将储存在内存中的数据库状态保存到磁盘里面，那么一旦服务器进程退出，服务器中的数据库状态也会消失不见。因此需要持久化机制。

> RDB持久化通过保存数据库中的键值对来记录数据库状态。

RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件，通过该文件可以还原生成RDB文件时的数据库状态。

### RDB文件的创建

有两个Redis命令可以用于生成RDB（Redis DataBase）文件，一个是SAVE，另一个是BGSAVE。

- SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求。
- BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。

redis 在进行数据持久化的过程中，会先将数据写入到一个临时文件中，待持久化过程都结束了，才会用这个临时文件替换上次持久化好的文件。正是这种特性，让我们可以随时来进行备份，因为快照文件总是完整可用的。

服务器在载入RDB文件期间，会一直处于阻塞状态，直到载入工作完成为止。

### 自动间隔性保存

因为BGSAVE命令可以在不阻塞服务器进程的情况下执行，所以Redis允许用户通过设置服务器配置的save选项，让服务器每隔一段时间自动执行一次BGSAVE命令。

用户可以通过save选项设置多个保存条件，但只要其中任意一个条件被满足，服务器就会执行BGSAVE命令。

	save 900 1
	save 300 10
	save 60 10000
	
那么只要满足以下三个条件中的任意一个，BGSAVE命令就会被执行：

- 服务器在900秒之内，对数据库进行了至少1次修改。
- 服务器在300秒之内，对数据库进行了至少10次修改。
- 服务器在60秒之内，对数据库进行了至少10000次修改。


<br/>


## AOF持久化

> AOF（Append Only File）持久化，通过保存Redis服务器所执行的写命令来记录数据库状态的。


因为AOF文件的更新频率通常比RDB文件的更新频率高，所以：

- 如果服务器同时开启了RDB和AOF持久化功能，那么服务器会优先使用AOF文件来还原数据库状态，因为 AOF 方式的数据恢复完整度更高。。
- 只有在AOF持久化功能处于关闭状态时，服务器才会使用RDB文件来还原数据库状态。

如果没有数据持久化的需求，也完全可以关闭 RDB 和 AOF 方式，这样的话，redis 将变成一个纯内存数据库，就像 memcache 一样。

### AOF 文件重写
因为采用了追加方式，如果不做任何处理的话，AOF 文件会变得越来越大，为此，redis 提供了 AOF 文件重写（rewrite）机制，即当 AOF 文件的大小超过所设定的阈值时，redis 就会启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。

举个例子，假如我们调用了 100 次 INCR 指令，在 AOF 文件中就要存储 100 条指令，但这明显是很低效的，完全可以把这 100 条指令合并成一条 SET 指令，这就是重写机制的原理。

在进行 AOF 重写时，仍然是采用先写临时文件，全部完成后再替换的流程，所以断电、磁盘满等问题都不会影响 AOF 文件的可用性。

缺点：在同样数据规模的情况下，AOF 文件要比 RDB 文件的体积大。而且，AOF 方式的恢复速度也要慢于 RDB 方式。

#### 重写过程

1. 在重写即将开始之际，redis 会创建（fork）一个“重写子进程”，这个子进程会首先读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。
2. 与此同时，主工作进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。
3. 当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中。
4. 当追加结束后，redis 就会用新 AOF 文件来代替旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中了。

### 如何选择RDB和AOF

官方的建议是**两个同时使用**，这样可以提供更可靠的持久化方案。


<br/>

## Redis Pipeline

流水线操作有助于客户端向服务器发送多个请求，而无需等待回复，最后只需一步即可读取回复。

Redis 流水线操作的主要优点是提高了 Redis 的性能。由于多个命令同时执行，它极大地提高了协议性能。

<br/>

## 事件

Redis服务器是一个事件驱动程序，服务器需要处理以下两类事件：

- 文件事件（file event）：Redis服务器通过套接字与客户端（或者其他Redis服务器）进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端（或者其他服务器）的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。
- 时间事件（time event）：Redis服务器中的一些操作（比如serverCron函数）需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。


<br/>

## 客户端

Redis服务器是典型的一对多服务器程序：一个服务器可以与多个客户端建立网络连接，每个客户端可以向服务器发送命令请求，而服务器则接收并处理客户端发送的命令请求，并向客户端返回命令回复。

通过使用由**I/O多路复用技术**实现的文件事件处理器，**Redis服务器使用单线程单进程的方式来处理命令请求**，并与多个客户端进行网络通信。（redis6 中，多线程？）

<br/>

## 服务端

一个命令请求从发送到完成主要包括以下步骤：1）客户端将命令请求发送给服务器；2）服务器读取命令请求，并分析出命令参数；3）命令执行器根据参数查找命令的实现函数，然后执行实现函数并得出命令回复；4）服务器将命令回复返回给客户端。

serverCron函数默认每隔100毫秒执行一次，它的工作主要包括更新服务器状态信息，处理服务器接收的SIGTERM信号，管理客户端资源和数据库状态，检查并执行持久化操作等等。

服务器从启动到能够处理客户端的命令请求需要执行以下步骤：1）初始化服务器状态；2）载入服务器配置；3）初始化服务器数据结构；4）还原数据库状态；5）执行事件循环。


<br/>

## 复制

在Redis中，用户可以通过执行SLAVEOF命令或者设置slaveof选项，让一个服务器去复制（replicate）另一个服务器，我们称呼被复制的服务器为主服务器（master），而对主服务器进行复制的服务器则被称为从服务器（slave）。

Redis的复制功能分为同步（sync）和命令传播（command propagate）两个操作：

- 同步操作用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态。
- 命令传播操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现不一致时，让主从服务器的数据库重新回到一致状态。


### 复制功能

Redis从2.8版本开始，使用PSYNC命令代替SYNC命令来执行复制时的同步操作。

PSYNC命令具有完整重同步（full resynchronization）和部分重同步（partial resynchronization）两种模式：

- 其中完整重同步用于处理初次复制情况：完整重同步的执行步骤和SYNC命令的执行步骤基本一样，它们都是通过让主服务器创建并发送RDB文件，以及向从服务器发送保存在缓冲区里面的写命令来进行同步。
- 部分重同步则用于处理断线后重复制情况：当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。

#### 全部复制
![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_server_sync.png)


### 命令传播

命令传播操作：主服务器将自己执行的写命令，也即是造成主从服务器不一致的那条写命令，发送给从服务器执行，当从服务器执行了相同的写命令之后，主从服务器将再次回到一致状态。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_server_sync_command.png)

<br/>

## Sentinel 哨兵

Sentinel（哨岗、哨兵）是Redis的高可用性（high availability）解决方案：由一个或多个Sentinel实例（instance）组成的Sentinel系统（system）可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_server_sentinel.png)

### 领头Sentinel

当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个Sentinel会进行协商，选举出一个领头Sentinel，并由领头Sentinel对下线主服务器执行故障转移操作。


### 故障转移

在选举产生出领头Sentinel之后，领头Sentinel将对已下线的主服务器执行故障转移操作，该操作包含以下三个步骤：

- 在已下线主服务器属下的所有从服务器里面，挑选出一个从服务器，并将其转换为主服务器。
- 让已下线主服务器属下的所有从服务器改为复制新的主服务器。
- 将已下线主服务器设置为新的主服务器的从服务器，当这个旧的主服务器重新上线时，它就会成为新的主服务器的从服务器。


<br/>

## 集群

Redis集群是Redis提供的分布式数据库方案，集群通过分片（sharding）来进行数据共享，并提供复制和故障转移功能。



<br/>

## Redis架构模式

### 单机版

问题：

1. 内存容量有限 2. 处理能力有限 3. 无法高可用。


### 主从复制


![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_architecture_masterslave.png)
特点：

1. master/slave 角色
2. master/slave 数据相同
3. 降低 master 读压力在转交从库

问题：

- 无法保证高可用
- 没有解决 master 写的压力


### 集群（proxy 型）
![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_architecture_proxy.png)

Twemproxy 是一个 Twitter 开源的一个 redis 和 memcache 快速/轻量级代理服务器； Twemproxy 是一个快速的单线程代理程序，支持 Memcached ASCII 协议和 redis 协议。

特点：

1. 多种 hash 算法：MD5、CRC16、CRC32. CRC32a、hsieh、murmur、Jenkins

2. 支持失败节点自动删除

3. 后端 Sharding 分片逻辑对业务透明，业务方的读写方式和操作单个 Redis 一致

缺点：增加了新的 proxy，需要维护其高可用。

failover 逻辑需要自己实现，其本身不能支持故障的自动转移可扩展性差，进行扩缩容都需要手动干预


### 集群（直连型）：

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_architecture_zhilian.png)
从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接。

特点：

1. 无中心架构（不存在哪个节点影响性能瓶颈），少了 proxy 层。

2. 数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。

3. 可扩展性，可线性扩展到 1000 个节点，节点可动态添加或删除。

4. 高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做备份数据副本

5. 实现故障自动 failover，节点之间通过 gossip 协议交换状态信息，用投票机制完成 Slave到 Master 的角色提升。

缺点：

1. 资源隔离性较差，容易出现相互影响的情况。

2. 数据通过异步复制,不保证数据的强一致性


### 哨兵
![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_architecture_sentinel.png)

Redis sentinel 是一个分布式系统中监控 redis 主从服务器，并在主服务器下线时自动进行故障转移。其中三个特性：

- 监控（Monitoring）： Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。
- 提醒（Notification）： 当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。
- 自动故障迁移（Automatic failover）： 当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作。

特点：

1. 保证高可用
2. 控各个节点
3. 自动故障迁移

缺点：

- 主从模式，切换需要时间丢数据
- 没有解决 master 写的压力




<br/>


## Redis分区

分区用于将 Redis 数据拆分为多个 Redis 实例，以便每个实例仅包含一部分 key。

它通常用于大型数据库。
分区类型

redis 中有两种类型的分区：

- 范围分区，它通过将对象的范围映射到特定的 Redis 实例来完成。
- 哈希分区，散列函数用于将 key 转换为数字，然后将数据存储在不同的 Redis 实例中。



<br/>

## 发布与订阅

Redis的发布与订阅功能由PUBLISH、SUBSCRIBE、PSUBSCRIBE等命令组成。

通过执行SUBSCRIBE命令，客户端可以订阅一个或多个**频道**，从而成为这些频道的订阅者（subscriber）：每当有其他客户端向被订阅的频道发送消息（message）时，频道的所有订阅者都会收到这条消息。


除了订阅频道之外，客户端还可以通过执行PSUBSCRIBE命令订阅一个或多个**模式**，从而成为这些模式的订阅者：每当有其他客户端向某个频道发送消息时，消息不仅会被发送给这个频道的所有订阅者，它还会被发送给所有与这个频道相匹配的模式的订阅者。

### 实现

服务器状态在pubsub_channels字典保存了**所有频道的订阅关系**：SUBSCRIBE命令负责将客户端和被订阅的频道关联到这个字典里面，而UNSUBSCRIBE命令则负责解除客户端和被退订频道之间的关联。

服务器状态在pubsub_patterns链表保存了**所有模式的订阅关系**：PSUBSCRIBE命令负责将客户端和被订阅的模式记录到这个链表中，而PUNSUBSCRIBE命令则负责移除客户端和被退订模式在链表中的记录。

PUBLISH命令通过访问pubsub_channels字典来向频道的所有订阅者发送消息，通过访问pubsub_patterns链表来向所有匹配频道的模式的订阅者发送消息。

PUBSUB命令的三个子命令都是通过读取pubsub_channels字典和pubsub_patterns链表中的信息来实现的。



<br/>

## Lua脚本

通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。



<br/>

## 一致性hash和哈希槽

### 一致性hash算法解决的问题

当数据太大而无法存储在一个节点或机器上时，系统中需要多个redis节点或机器来存储数据。比如，使用多个 Web 缓存中间件的系统。

那如何确定哪个 key 存储在哪个节点上？最简单的解决方案是使用哈希取模来确定。 给定一个 key，先对 key 进行哈希运算，将其除以系统中的节点数，然后将该 key 放入该节点。同样，在获取 key 时，对 key 进行哈希运算，再除以节点数，然后转到该节点并获取值。

	node_number = hash(key) % N  # 其中 N 为节点数。

当节点宕机节点减少，或流量突增增加机器时，由于节点数变化导致key与节点的映射关系变化。这个变化对于新的键来说没有什么影响，但是对于已有的key，就会导致映射规则错误，即缓存失效。若同一时刻出现大量的缓存失效，则可能会出现 “缓存雪崩”，这将会造成灾难性的后果。

一致性哈希算法优点

1. 可扩展性。一致性哈希算法保证了增加或减少服务器时，数据存储的改变最少，相比传统哈希算法大大节省了数据移动的开销 。
2. 更好地适应数据的快速增长。采用一致性哈希算法分布数据，当数据不断增长时，部分虚拟节点中可能包含很多数据、造成数据在虚拟节点上分布不均衡，此时可以将包含数据多的虚拟节点分裂，这种分裂仅仅是将原有的虚拟节点一分为二、不需要对全部的数据进行重新哈希和划分。
	
	虚拟节点分裂后，如果物理服务器的负载仍然不均衡，只需在服务器之间调整部分虚拟节点的存储分布。这样可以随数据的增长而动态的扩展物理服务器的数量，且代价远比传统哈希算法重新分布所有数据要小很多。

### 一致性hash

一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。

- 一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形）。

整个空间按顺时针方向组织，0和2^32-1在零点中方向重合。

- 接下来，把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。 

- 然后，我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。

例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_consistent_hash.png)


假如RedisService2宕机了，数据B对应的节点保存到RedisService3中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_consistent_hash_down.png)


假如增加一台服务器Redis4，原本数据C是保存到Redis3中，但由于增加了Redis4，数据C被保存到Redis4中。干扰的也只有Redis3而已，其他数据不会受到影响。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_consistent_hash_add.png)


因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性。

#### 虚拟节点

如果节点较少，会出现节点分布不均衡造成数据倾斜问题。

为了解决这种数据存储不平衡的问题，一致性哈希算法引入了**虚拟节点机制**，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点称为虚拟节点。
具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、 RedisService1#2、 RedisService1#3、 RedisService2#1、 RedisService2#2、 RedisService2#3，具体位置如下图所示：

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_consistent_hash_virtual.png)

对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。


### 哈希槽

哈希槽是在**redis cluster**集群方案中采用的，redis cluster集群没有采用一致性哈希方案，而是采用数据分片中的哈希槽来进行数据存储与读取的。

redis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。主要的原因就是，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。

首先哈希槽其实是两个概念，第一个是哈希算法。redis cluster 的 hash 算法不是简单的 hash()，而是 crc16 算法，一种校验算法。另外一个就是槽位的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而 redis cluster 的槽位空间是自定义分配的，类似于 windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。

redis cluster 包含了16384个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。

另外在容错性和扩展性上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。

但一定要注意的是，对于槽位的转移和分派，redis 集群是不会自动进行的，而是需要人工配置的。所以 redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。

![](https://raw.githubusercontent.com/rainsbaby/notebook/master/imgs/redis/redis_hash_slot.png)

好处：

- 使用哈希槽的好处就在于可以方便的添加或移除节点。
- 当需要增加节点时，只需要把其他节点的某些哈希槽挪到新节点就可以了；
- 当需要移除节点时，只需要把移除节点上的哈希槽挪到其他节点就行了；


<br/>

## 应用

### Redis分布式锁

#### 分布式锁
分布式锁是，控制分布式系统不同进程共同访问共享资源的一种锁的实现。如果不同的系统或同一个系统的不同主机之间共享了某个临界资源，往往需要互斥来防止彼此干扰，以保证一致性。

特征：

- 互斥性: 任意时刻，只有一个客户端能持有锁。
- 锁超时释放：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。
- 可重入性:一个线程如果获取了锁之后,可以再次对其请求加锁。
- 高性能和高可用：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。
- 安全性：锁只能被持有的客户端删除，不能被其他客户端删除


#### 分布式锁实现方式
1. Memcache分布式锁
2. Zookeeper
3. Chubby
4. Redis


#### Redis分布式锁

有以下多种方案：

- 单机SETNX + EXPIRE。 setnx和expire两个命令分开了，不是原子操作。发生异常时锁得不到释放。
- SETNX + value值是（系统时间+过期时间）。
	- 过期时间是客户端自己生成的（System.currentTimeMillis()是当前系统的时间），必须要求分布式环境下，每个客户端的时间必须同步。
	- 如果锁过期的时候，并发多个客户端同时请求过来，都执行jedis.getSet()，最终只能有一个客户端加锁成功，但是该客户端锁的过期时间，可能被别的客户端覆盖。
	- 该锁没有保存持有者的唯一标识，可能被别的客户端释放/解锁。
- 使用Lua脚本(包含SETNX + EXPIRE两条指令)。使用Lua脚本来保证原子性（包含setnx和expire两条指令）。
	- 当前线程执行超时锁被提前释放后，其他线程会取得锁，进而导致并发执行。
- SET的扩展命令（SET EX PX NX）。Redis的SET指令扩展参数（SET key value[EX seconds][PX milliseconds][NX|XX]），它也是原子性的。
- SET EX PX NX  + 校验唯一随机值,再释放锁。
- 开源框架:Redisson。利用守护进程解决锁被提前释放的问题。
	- 利用锁的可重入特性，让获得锁的线程开启一个定时器的守护线程，每 expireTime/3 执行一次，去检查该线程的锁是否存在，如果存在则对锁的过期时间重新设置为 expireTime，即利用守护线程对锁进行“续命”，防止锁由于过期提前释放。
	- 支持 Redis 单实例、Redis M-S、Redis Sentinel、Redis Cluster 等多种部署架构。
- 多机实现的分布式锁Redlock+Redisson。RedLock算法解决以上方法在加锁时只作用在一个 Redis 节点上的问题，即使 Redis 通过 Sentinel 保证了高可用，但由于 Redis 的复制是异步的，Master 节点获取到锁后在未完成数据同步的情况下发生故障转移，此时其他客户端上的线程依然可以获取到锁，因此会丧失锁的安全性。
	- Redisson实现了RedLock版本的锁。
	- RedLock算法中，利用多个Redis master部署，以保证它们不会同时宕掉。并且这些master节点是完全相互独立的，相互之间不存在数据同步。同时，需要确保在这多个master实例上，是与在Redis单实例，使用相同方法来获取和释放锁。
	- 假设有5个master，按顺序向5个master节点请求加锁
	- 根据设置的超时时间来判断，是不是要跳过该master节点。
	- 如果大于等于三个节点加锁成功，并且使用的时间小于锁的有效期，即可认定加锁成功啦。
	- 如果获取锁失败，解锁。



### Redis异步队列

一般使用**list 结构作为队列**，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。不但客户端的 CPU 能降下来，Redis 的 QPS 也降下来了。

**如果对方追问可不可以不用 sleep 呢？**

用 blpop/brpop 替代前面的 lpop/rpop，list 还有个指令叫 blpop阻塞读在队列没有数据的时候，会立即进入休眠状态，一旦数据到来，则立刻醒过来。消息的延迟几乎为零。

如果对方追问能不能生产一次消费多次呢？

使用 **pub\/sub 主题订阅者模式**，可以实现1:N 的消息队列。

**如果对方追问 pub/sub 有什么缺点？**

在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 RabbitMQ等。Redis5.0 新增了 Stream 数据结构，这个功能给 Redis 带来了持久化消息队列。

**如果对方追问 redis 如何实现延时队列？**

延时队列可以通过 Redis 的 **zset(有序列表)** 来实现。我们将消息序列化成一个字符串作为 zset 的 value，这个消息的到期处理时间作为 score，然后用多个线程轮询 zset 获取到期的任务进行处理，多个线程是为了保障可用性，万一挂了一个线程还有其它线程可以继续处理。

### Redis实现限流
常见的限流算法有：计数器，漏桶、令牌桶。

#### 计数器（时间窗口）

记录每个请求，判断在设定的限流时间窗口内请求数是否大于限制数。限流要注意避免边界问题，滑动时间窗口的方法能很好解决这个问题。

利用 Redis 有序集合实现，并用管道加速。

#### 漏桶 (Leaky Bucket) 

漏桶算法：水 (请求) 先进入到漏桶里，漏桶以一定的速度出水 (接口有响应速率), 当水流入速度过大会直接溢出 (访问频率超过接口响应速率), 然后就拒绝请求，可以看出漏桶算法能强行限制数据的传输速率。

利用 Redis-Cell 模块实现。

#### 令牌桶算法

系统按恒定 1/QPS 时间间隔 (如果 QPS=100, 则间隔是 10ms) 往桶里加入 Token (想象和漏洞漏水相反，有个水龙头在不断的加水), 如果桶已经满了就不再加了。新请求来临时，会各自拿走一个 Token, 如果没有 Token 可拿了就阻塞或者拒绝服务。

利用 Redis String + 定时任务实现。

- 利用定时任务不断增加令牌数，Redis->incr()，自增一，令牌桶满则不再增加；
- 来一个请求消耗一个令牌，Redis->decr()，自减一，当没有令牌时则拒绝请求。
- 一旦需要提高速率，则按需提高放入桶中的令牌的速率即可。


### 什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？

#### 缓存穿透

一般的缓存系统，都是按照key去缓存查询，如果不存在对应的value，就应该去后端系统查找（比如DB）。一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。

如何避免？

1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。

2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤。

#### 缓存雪崩

当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。

如何避免？

1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。

2：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期

3：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。


### Redis的用途

**计数器** 可以对 String 进行自增自减运算，从而实现计数器功能。Redis 这种内存型数据库的读写性能非常高，很适合存储频繁读写的计数量。

**缓存**将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。

**会话缓存** 可以使用 Redis 来统一存储多台应用服务器的会话信息。当应用服务器不再存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。

**全页缓存**（FPC） 除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。以 Magento 为例，Magento 提供一个插件来使用 Redis 作为全页缓存后端。此外，对 WordPress 的用户来说，Pantheon 有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。

**查找表** 例如 DNS 记录就很适合使用 Redis 进行存储。查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，而缓存的内容可以失效，因为缓存不作为可靠的数据来源。

**消息队列(发布/订阅功能)** List 是一个双向链表，可以通过 lpush 和 rpop 写入和读取消息。不过最好使用 Kafka、RabbitMQ 等消息中间件。

**分布式锁实现** 在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用 Redis 自带的 SETNX 命令实现分布式锁，除此之外，还可以使用官方提供的 RedLock 分布式锁实现。

其它 Set 可以实现交集、并集等操作，从而实现共同好友等功能。ZSet可以实现有序性操作，从而实现排行榜等功能。

位图，利用SETBIT等命令可实现位图，底层利用的是SDS数据结构。

**HyperLogLog**，一种非常巧妙的近似统计海量去重元素数量的算法，可用于统计网站UV等。

**布隆过滤器**， 一个很长的二进制向量和一系列随机映射函数。 布隆过滤器可以用于检索一个元素是否在一个集合中。 它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。


### Redis的主要特点

 Redis 的主要功能：

    读写性能优异
    支持数据持久化，支持 AOF 和 RDB 两种持久化方式。
    支持事务，Redis 的所有操作都是原子性的，同时 Redis 还支持对几个操作合并后的原子性执行。
    数据结构丰富，除了支持 string 类型的 value 外还支持 hash、set、zset、list 等数据结构。
    支持主从复制，主机会自动将数据同步到从机，可以进行读写分离。



###热点缓存问题

#### 缓存优化

在DB数据中，某些数据的访问量比较大，成为热点数据。

1. 首先用redis缓存，减少DB压力。先从缓存中获取，没有再到DB获取，并保存到缓存中。

2. 但是，热点数据的访问会比较大，如果缓存一旦失效，所有请求同一时刻，会打到DB上面，DB肯定会崩溃。

	- 方案一，把请求放入队列中处理。
	- 方案二，利用分布式锁，只允许一个请求线程去访问DB，其他请求阻塞，这样就避免了很多请求打到DB上。
	- 方案三，让缓存永不过期。需要在热点商品上线前进行预热，提前缓存热点key；还需要在db中数据变化时，及时更新缓存。

3. 如果达到了单台redis机器的负载极限怎么办？

	- Redis集群部署
	- 读写分离。默认是由主redis提供读写服务，从redis收到请求会转发给主redis。可以在操作读请求时，先加上readonly命令，这样从redis就可以提供读请求服务了，不需要转发到主redis。
	- 二级缓存。改造web应用服务，在获取到redis缓存后，在web服务本地把热点的数据进行缓存。
	- 备份热点key。将热点key存在多个redis节点上，访问热点key时随机选择节点。

#### 热点发现

因为本地缓存资源有限，不可能把所有的商品数据进行缓存，它只会缓存热点的数据。怎么知道哪些数据是热点数据？

1. 人为预测。根据运营人员的经验进行预测。
2. 系统推算。根据实实在在的数据访问量进行推算。
3. 利用redis4.x自身特性，LFU机制发现热点数据。只要把redis内存淘汰机制设置为allkeys-lfu或者volatile-lfu方式，再执行./redis-cli --hotkeys命令，会返回访问频率高的key，并从高到底的排序。



<br/>

## 与其他中间件对比

### Redis与memcache的区别

| 项目  | Memcache  | Redis |
|:------------- |:---------------:| -------------:|
| 定义      | Memcached 是内存中的键值存储，最初用于缓存目的。 |        Redis 是内存中的数据结构存储，用作数据库，缓存和消息代理。 |
| 许可      | 免费开源     |           免费开源		 |
| 实现语言 | c语言        |            c语言			 |
|复制方法  |无		  |		主从复制		|
|持久化	| 无			|		可以持久化数据	|
|复制 	| Memcached 不支持复制 | 	Redis 支持主从复制 |
| 执行速度和性能	| 	MemcacheD 非常适合处理高流量网站。它可以一次读取许多信息，并在很长的响应时间内返回 | Redis 既不能处理读取时的高流量，也不能处理繁重的写入 |


### redis 和 mongodb 比较
|项目 | 	Redis	| 	MongoDB	|
|:------------- |:---------------:| -------------:|
|主数据库模型 	|	Redis 遵循键值存储模型 |	MongoDB 遵循文档存储模型|
|许可 			| Redis 是基于订阅和开源的	| 	MongoDB 可以免费使用和开源 |
|基于云 			 | 没有 						|	没有 |
|实现语言 		| C 语言						| C ++语言 |
|数据 Scheme	 |	无 		| 	无		|
|二级索引 		|	没有 	|	有		|
|SQL 支持 		|	没有 	|	没有	|
|分区方法 		| 使用 Sharding 进行分区 | 	使用 Sharding 进行分区 |
| 复制方法 		| 主从复制	| 	主从复制 |
|MapReduce 	|	没有	 |	是		|
|一致性概念 		|	最终的一致性和即时一致性  | 最终的一致性  |
|并发 			|是 			|	是		|
|持久化 			|是 			|	是		|


### Redis和RDBMS有什么区别？


    Redis 是 NoSQL 数据库，而 RDBMS 是 SQL 数据库。
    Redis 遵循键值结构，而 RDBMS 遵循表结构。
    Redis 非常快，而 RDBMS 相对较慢。
    Redis 将所有数据集存储在主存储器中，而 RDBMS 将其数据集存储在辅助存储器中。
    Redis 通常用于存储小型和常用文件，而 RDBMS 用于存储大文件。
    Redis 仅为 Linux，BSD，Mac OS X，Solaris 提供官方支持。它目前没有为 Windows 提供官方支持，而 RDBMS 提供对两者的支持。



###为什么Redis不同于其他的键值存储数据库？


    Redis发展方向不同与其他键值数据库，**它能包含很多复杂数据类型，对这些数据类型操作都是原子的。**Redis数据类型与基本数据结构强相关，直接暴露给程序员，没有增加抽象层。
    Redis是一个基于内存的，能够持久化到硬盘的数据库，因此为**了实现高速读写，数据集大小不能超过内存。**内存数据库另一个优点是，内存数据库相对于硬盘数据库非常容易操作复杂数据结构，因此Redis的可以做很多事情，内部复杂性低。与此同时两款磁盘存储格式（RDB和AOF）不需要支持随机访问，因此他们是紧凑的，而且总是以追加形式生成（甚至AOF日志轮换也是一个追加操作，因为新版本是由内存中的副本生成）。比起基于磁盘的数据存储， Redis 用来处理重要数据时需要确保数据集及时落盘刷新。


<br/>

## 参考

《Redis设计与实现》

[Redis中文文档](https://www.redis.com.cn/redis-intro.html)

[Redis分布式锁](https://juejin.cn/post/6936956908007850014)

